# 現状理解と次のステップ

## 📋 現状の理解

### ✅ 既に存在しているもの

1. **ソースコード（実装済み）**
   - `backend/lambda/` - API Lambda の実装
   - `backend/ingest/` - Ingest Lambda の実装
   - `backend/scripts/create_index.py` - OpenSearch インデックス作成スクリプト
   - `web/` - Next.js フロントエンド
   - `構想1106.py` - 実装指示書

2. **ドキュメント**
   - `AWS構成/00_overview.md` - 全体像ドキュメント
   - `AWS構成/01_backend_api.md` - （空ファイル）

### 🔍 ソースコードから確認できた実装詳細

#### 1. OpenSearch Index Mapping（`backend/scripts/create_index.py`）

```python
mapping = {
  "settings": {"index": {"knn": True}},
  "mappings": {"properties": {
    "text": {"type":"text"},
    "title":{"type":"text"},
    "vector":{"type":"knn_vector","dimension":1024,"method":{"name":"hnsw","space_type":"cosinesimil"}},
    "vendor_name":{"type":"keyword"},
    "meeting_date":{"type":"date"},
    "participants":{"type":"keyword"},
    "doc_type":{"type":"keyword"},
    "tags":{"type":"keyword"}
  }}
}
```

**確認できた情報：**
- ベクトルフィールド名：`vector`
- ベクトルの型：`knn_vector`
- 次元数：`1024`（Titan v2 のデフォルト）
- 距離関数：`cosinesimil`（コサイン類似度）
- インデックス方式：`hnsw`
- メタデータフィールド：`vendor_name`, `meeting_date`, `participants`, `doc_type`, `tags`

#### 2. API の検索実装（`backend/lambda/opensearch_client.py`）

**確認できた情報：**
- ハイブリッド検索：BM25 + k-NN → RRF（Reciprocal Rank Fusion）で融合
- BM25 クエリ：`multi_match` で `text^2` と `title` を検索（`text` に2倍の重み）
- k-NN クエリ：`vector` フィールドに対してコサイン類似度検索
- フィルター：`filters` パラメータで `term` クエリを適用
- デフォルト取得数：`k=8`（最終結果）、各検索で `max(50, k * 5)` 件取得してから RRF

#### 3. API エンドポイント（`backend/lambda/app.py`）

**確認できた情報：**
- HTTP メソッド：`GET` のみ対応
- クエリパラメータ：`q`（必須）
- 現在の実装では `filters` パラメータは未使用（`filters={}` 固定）
- レスポンス：`{"query": str, "results": [...]}`

#### 4. Ingest Pipeline（`backend/ingest/app.py`）

**確認できた情報：**
- チャンクサイズ：`chunk=900` 文字、`overlap=150` 文字（`preprocess.py` より）
- メタデータ抽出：`extract_meta()` で `date:` と `#tag` を抽出
- ベクトル生成：`embed_texts()` で各チャンクをベクトル化
- 保存形式：`{"text": str, "vector": list[float], **meta}`

---

## ❗ 現時点での課題と推測が必要な部分

### 🔴 推測で書かざるを得ない部分

1. **API のフィルター機能**
   - 現在の実装では `filters={}` 固定
   - フロントエンド（`web/components/search/Filters.tsx`）では `vendor`, `from`, `to` を送信する想定
   - **推測が必要**：フィルターの実装方法（クエリパラメータ？リクエストボディ？）

2. **OpenSearch Serverless 対応**
   - 現在の mapping は OpenSearch Service（マネージド）用
   - OpenSearch Serverless の場合、`knn_vector` の設定が異なる可能性
   - **推測が必要**：Serverless 用の mapping 調整

3. **認証方式**
   - 現在のコード：`OS_USER`, `OS_PASS` 環境変数（Basic認証）
   - OpenSearch Serverless は IAM 認証が基本
   - **推測が必要**：IAM 認証への移行方法

4. **エラーハンドリング**
   - 現在の実装は最小限
   - **推測が必要**：詳細なエラーレスポンス形式

---

## 🟦 ソースコードが必要になる理由（再確認）

### ✔ Index の mapping は実装に強く依存

**既に確認済み：**
- ✅ チャンク方式：`split_text_jp(chunk=900, overlap=150)`
- ✅ メタデータの項目：`vendor_name`, `meeting_date`, `participants`, `doc_type`, `tags`
- ✅ ベクトルのフィールド名：`vector`
- ✅ ベクトルの型：`knn_vector`
- ✅ 次元数：`1024`

**未確認・推測が必要：**
- ❓ OpenSearch Serverless 用の k-NN 設定（`knn_vector` vs `float[]`）
- ❓ analyzer の設定（日本語対応？）

### ✔ API の設計もソースで決まる

**既に確認済み：**
- ✅ 検索パラメータ：`q`（クエリ文字列）
- ✅ OpenSearch の検索クエリ：BM25 + k-NN → RRF
- ✅ ベクトルとキーワードの組み合わせ方：RRF で融合

**未確認・推測が必要：**
- ❓ ベンダー名ベースのフィルターの挙動（現在未実装）
- ❓ 日付範囲フィルターの実装方法
- ❓ ページネーション（`from`, `size` パラメータ）

### ✔ Ingest Pipeline のコードが無いと

**既に確認済み：**
- ✅ チャンクサイズ：`900` 文字、`150` 文字オーバーラップ
- ✅ メタデータの抽出：`extract_meta()` で `date:` と `#tag` を抽出
- ✅ `vendor_name` の取り扱い：S3 キーから推測？メタデータから？

**未確認・推測が必要：**
- ❓ `vendor_name` の取得方法（S3 キーのパス？Markdown の frontmatter？）
- ❓ `timestamp` フィールドの有無（`meeting_date` のみ？）

---

## 🧠 ソースが揃えばできること

### 🔧 1. OpenSearch index mapping の完全版を生成

**現状：**
- 基本的な mapping は `create_index.py` に存在
- OpenSearch Serverless 対応が未確認

**必要な作業：**
- [ ] OpenSearch Serverless 用の mapping を確認・調整
- [ ] analyzer の設定（日本語対応）
- [ ] `timestamp` フィールドの追加検討
- [ ] インデックステンプレートの作成

### 🤖 2. API の仕様書を作成（OpenAPI 3.0）

**現状：**
- 基本的な実装は存在
- フィルター機能が未実装

**必要な作業：**
- [ ] フィルター機能の実装（`vendor`, `from`, `to`）
- [ ] エラーレスポンスの統一
- [ ] OpenAPI 3.0 仕様書の生成
- [ ] サンプルコード生成（curl, Python, TypeScript）

### 📦 3. Ingest Pipeline の改善

**現状：**
- 基本的な実装は存在
- `vendor_name` の取得方法が不明

**必要な作業：**
- [ ] `vendor_name` の取得ロジックを明確化
- [ ] S3 キーのパス解析（例：`vendors/{vendor_name}/{date}.md`）
- [ ] エラーハンドリングの強化
- [ ] bulk API の最適化（バッチサイズ調整）

### 🖥️ 4. Next.js / Lambda 連携の最適化

**現状：**
- フロントエンドの実装は存在
- API 連携の設定は `.env.local` で管理

**必要な作業：**
- [ ] Amplify hosting 時の環境変数管理
- [ ] CORS 設定の確認
- [ ] エラーハンドリングの統一

---

## 📝 次のステップ：優先順位

### 🔴 高優先度（すぐに必要）

1. **フィルター機能の実装**
   - `backend/lambda/app.py` で `filters` パラメータを処理
   - `vendor_name`, `from`, `to` のフィルターを実装

2. **OpenSearch Serverless 対応の確認**
   - 使用する OpenSearch の種類を確認（Service vs Serverless）
   - 必要に応じて mapping を調整

3. **`vendor_name` の取得方法の明確化**
   - S3 キーのパスから取得するか、Markdown の frontmatter から取得するか

### 🟡 中優先度（後で対応可能）

4. **エラーハンドリングの強化**
   - 詳細なエラーレスポンス形式の定義
   - ログ出力の改善

5. **OpenAPI 仕様書の作成**
   - API の完全な仕様を文書化
   - フロントエンドとの型整合性確保

### 🟢 低優先度（最適化段階）

6. **パフォーマンス最適化**
   - bulk API のバッチサイズ調整
   - キャッシュ戦略の検討

---

## 💡 LLM への指示（このドキュメントの目的）

このドキュメントは、**LLM（AI アシスタント）に対して現状を正確に伝える**ためのものです。

### 伝えるべき情報

1. **既に実装されているもの**
   - ソースコードは存在し、基本的な機能は実装済み
   - OpenSearch mapping、API 実装、Ingest pipeline の基本構造は確認済み

2. **推測が必要な部分**
   - フィルター機能の実装方法
   - OpenSearch Serverless 対応
   - `vendor_name` の取得方法

3. **次のステップ**
   - 優先順位に基づいた実装タスク
   - 各タスクの詳細な要件

### LLM がすべきこと

1. **既存コードの理解**
   - ソースコードを読み、実装の意図を理解する
   - 推測が必要な部分を特定する

2. **不足している実装の追加**
   - フィルター機能の実装
   - エラーハンドリングの強化

3. **ドキュメントの生成**
   - OpenAPI 仕様書の作成
   - 実装ガイドの作成

---

## 📚 参考：既存のソースコード構造

```
backend/
├── lambda/
│   ├── app.py              # API Lambda ハンドラー
│   ├── opensearch_client.py  # OpenSearch 検索ロジック
│   ├── bedrock_client.py     # Bedrock 呼び出し
│   └── preprocess.py         # テキスト前処理
├── ingest/
│   └── app.py              # Ingest Lambda ハンドラー
├── scripts/
│   ├── create_index.py     # OpenSearch インデックス作成
│   └── ...
└── template.yaml           # SAM テンプレート
```

**各ファイルの役割は既に確認済み。次のステップは、不足している機能の実装とドキュメント化です。**

